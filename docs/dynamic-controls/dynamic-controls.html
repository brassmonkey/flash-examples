<html><head><title>Dynamic Controls</title><style type="text/css">ol{margin:0;padding:0}.c5{max-width:468pt;background-color:#ffffff;padding:72pt 72pt 72pt 72pt}.c6{font-size:14pt;font-weight:bold}.c2{font-size:24pt;font-weight:bold}.c3{font-size:18pt;font-weight:bold}.c8{font-style:italic}.c0{direction:ltr}.c7{text-indent:18pt}.c4{color:#1155cc}.c1{padding-bottom:5pt}.title{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:36pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}.subtitle{padding-top:18pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:24pt;font-family:"Georgia";padding-bottom:4pt}li{color:#000000;font-size:11pt;font-family:"Arial"}p{color:#000000;font-size:11pt;margin:0;font-family:"Arial"}h1{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:24pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}h2{padding-top:18pt;line-height:1.15;text-align:left;color:#000000;font-size:18pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h3{padding-top:14pt;line-height:1.15;text-align:left;color:#000000;font-size:14pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h4{padding-top:12pt;line-height:1.15;text-align:left;color:#000000;font-size:12pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}h5{padding-top:11pt;line-height:1.15;text-align:left;color:#000000;font-size:11pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}h6{padding-top:10pt;line-height:1.15;text-align:left;color:#000000;font-size:10pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}</style></head><body class="c5"><p class="c0"><img height="803" src="images/image00.png" width="621"><hr></p><p class="c0 c1"><span class="c2">Dynamic Controls With Flash</span></p><p class="c0 c1"><span class="c4">Dynamic Controls With Flash</span></p><p class="c0 c1"><span class="c4">Introduction Laying out a dynamic scheme with flash professional</span></p><p class="c0 c1"><span class="c4">View One Library Naming View Two</span></p><p class="c0 c1 c7"><span class="c4">Dynamic Text Putting It All Together Hardcore Control Scheme Usage</span></p><p class="c0 c1"><span class="c4">Using Multiple Schemes With a Single Device Toggle An Image Control and Screen Resolutions</span></p><p class="c0 c1"><span class="c3">Introduction</span></p><p class="c0 c1"><span>In Boot Camp, I showed how to create a simple control scheme with a background and a single button. A control scheme created in flash is just a movie clip exported for use at run-time. This document covers a more complex usage of the control scheme API. One new scheme operation to update the layout, and one new component, the text component, is covered. In addition, two different approaches to using the API from a flasher&rsquo;s perspective will be explained: One being a</span></p><hr style="page-break-before:always;display:none;"><p class="c0"><img height="803" src="images/image01.png" width="621"><hr></p><p class="c0 c1"><span>fairly predictable scheme created completely in the IDE, and the other being somewhat unpredictable using playing cards altered at run-time. Concerning text, there are two ways to embed text into your scheme, using the device text component with the android font, or using the flash TextField as is, embedding a snapshot of some text in the font of your choice.</span></p><p class="c0 c1"><span class="c3">Laying out a dynamic scheme with flash professional</span></p><p class="c0 c1"><span>If a movie clip which is parsed into control XML contains more than one frame, each frame will become a page-able view and class methods are present in the control scheme object instance to alter the attributes. Using these methods and sending the results, the client device will respond by hiding or showing the display objects, the views will be organized as they are on laid out in the flash timeline. View one is frame one, view two is frame two, and so on. As usual, objects can be re-used on different frames using the same unique name, allowing you to put the same button/image on every view if so desired.</span></p><p class="c0 c1"><span>View One Below is an example of a slightly more complex scheme than presented in boot camp. In total, there are 3 defined symbols on this frame. The red background, the dark button, and the light button. Just the same as boot camp, the background and &lsquo;up&rsquo; version of the buttons have unique names, while the &lsquo;down&rsquo; version which will be shared by the two buttons is off to the side and not named.</span></p><hr style="page-break-before:always;display:none;"><p class="c0"><img height="803" src="images/image02.png" width="621"><hr></p><p class="c0 c1"><span class="c6">Library Naming</span></p><p class="c0 c1"><span>The names of the symbol class definitions follows a simple naming convention. If you place an instance of a display object on the scheme clip, the parser will look for another symbol that has the string &lsquo;Down&rsquo; appended to the class name. On frame one of the above example scheme, there are two &lsquo;SchemeButton&rsquo; instances and a &lsquo;SchemeButtonDown&rsquo; instance, both exported for runtime sharing. There is also a TestBackground1 instance. Since the buttons symbol names yield a &lsquo;Down&rsquo; symbol, they be come buttons. The &lsquo;TestBackground1&lsquo; symbol did not yield another &lsquo;Down&rsquo; symbol so it becomes a static image representing the background.</span></p><p class="c0 c1"><span class="c3">View Two</span></p><p class="c0 c1"><span>Going to Frame 2 of this example scheme, there are five symbols defined, the background, the hex- dark, hex-light, triangle dark, and triangle light. In addition, there is a text field. The positioned dark versions are the &lsquo;up&rsquo; skins and each have a unique name.The light instances are un-named and off to the side. The &lsquo;down&rsquo; skins must always be below and to the right of the background.</span></p><hr style="page-break-before:always;display:none;"><p class="c0"><img height="803" src="images/image03.png" width="621"><hr></p><p class="c0 c1"><span>Dynamic Text View two contains the dynamic text set up. The text field in the example scheme has been named &lsquo;dynamicText&rsquo; with the flash properties panel, and is a direct child of the exported control scheme clip. This text field will become a text component using the device Droid Sans font. Any text fields placed as children of other symbols, such as putting &lsquo;FIRE&rsquo; on one of the buttons or image symbols used on the scheme will retain their font. Those embedded fonts on a symbol can be updated at runtime like any other flash text field before the snapshot of the resource is generated. For optimized dynamic text in your control, use the flash TextField placed directly on the scheme and give it a name with the properties panel. In this particular scheme, the text field instance is named &lsquo;dynamicText&rsquo;, and resides on frame 2.</span></p><p class="c0 c1"><span class="c3">Putting It All Together</span></p><p class="c0 c1"><span>First the movieclip must be parsed and added to the session:</span></p><hr style="page-break-before:always;display:none;"><p class="c0"><img height="803" src="images/image04.png" width="621"><hr></p><p class="c0 c1"><span>When the device client connects, by default it will receive page(frame) one. Here you can see the dark hex button replaced by the light version when I press it.</span></p><p class="c0 c1"><span>In the flash run-time using this methodology the app scheme movie clip frames are named as &lsquo;pages&rsquo;. So I will grab the text component, change the text, and send the page 2 (frame 2 ) to the device- client:</span></p><hr style="page-break-before:always;display:none;"><p class="c0"><img height="803" src="images/image06.png" width="621"><hr></p><p class="c0 c1"><span>Instead of seeing the text I used in the IDE, it has been updated to &lsquo;hrm&rsquo; before sending page two to the client. Also, instead of seeing the &lsquo;Impact&rsquo; font, we see the Droid Sans font.</span></p><hr style="page-break-before:always;display:none;"><p class="c0"><img height="803" src="images/image05.png" width="621"><hr></p><p class="c0 c1"><span class="c3">Hardcore Control Scheme Usage</span></p><p class="c0 c1"><span>This is a movie clip scheme with 6 image components, background and five cards. The five card images could have been buttons for tapping, however for simplicity, these are just images on our scheme. For this example Im using a full set of card images stored on the host, passing only the &lsquo;dealt&rsquo; card.. The rotational nature of the five card symbols is created by putting a card-back image on a definition, and then placing that symbol with some rotation applied to another symbol. This parent symbol is placed onto the control scheme. I have created Five card symbols this way, each with a different rotation. This was a quick and dirty way to swap card bitmaps and not worry about the rotation of that particular card at the client device.</span></p><p class="c0 c1"><span>Note that this is not the most optimized way to handle this scenario. All the cards could be sent up front and displayed without rotation, using the update call to re-reference the components to different images in the pool. This example will replace the card-back, re-create the skin associated with card1 button, and update the device with the generated scheme. In order to do this re-referencing, the existing one must be deleted. When the parser reads a movie clip, the bitmap skins for that display object are only created once. By removing the resource reference, the parser will be forced to re- make it. Using the code snippets below, the registration is removed so that the re-parsing will yield a new image for the updated device.</span></p><hr style="page-break-before:always;display:none;"><p class="c0"><img height="803" src="images/image08.png" width="621"><hr></p><p class="c0 c1"><span>The result of running that will encode a new resource and send it to my ipod, updating the controls from a set of five card-backs cards to one with a single card overturned.</span></p><p class="c0 c1"><span class="c8">Using Multiple Schemes With a Single Device This Applies specifically to applications that are using the SCHEME_BUTTON DeviceEvent.</span></p><hr style="page-break-before:always;display:none;"><p class="c0"><img height="803" src="images/image07.png" width="621"><hr></p><p class="c0 c1"><span>When an application chooses to use more than one control scheme with a single device, that is, if you literally send a whole new scheme, including resources as an update, it is very important to set changes to the session object. When the device is given a control scheme at the session start, the names of all the buttons in the assigned device control scheme are read, and the initial state for all buttons are set into the brassmonkey clientButtonStates object. This object is kept updated for the duration of the session with the current state of all buttons on all devices.</span></p><p class="c0 c1"><span>The Device can receive an entirely new control scheme as an update, and this scheme may contain new buttons that the session will not process during the update API call. As a result, the buttons with new names will not trigger the SCHEME_BUTTON DeviceEvent. To overcome this , before or immediately after sending the update, the session can re-initiate the button states with these calls:</span></p><p class="c0 c1"><span>//set new scheme ID to the device device.controlSchemeIndex=newSchemeID; //set initial &lsquo;up&rsquo; state of the buttons to the cache object. brassmonkey.session.registry.controlSchemes[device.controlSchemeIndex ]</span></p><p class="c0 c1"><span>.setInitialButtonState(brassmonkey.clientButtonStates[device.deviceId] );</span></p><p class="c0 c1"><span>By grabbing the desired scheme from controlSchemes array, which contains all the parsed BMApplicationScheme instances , and using the &lsquo;setInitialButtonState&rsquo; method of the desired instance, the new button names will be cached. Once these are known, the device can dispatch the new scheme button events.</span></p><p class="c0 c1"><span>The BMApplication object stores the name/state pairs of buttons indexed by device id:</span></p><p class="c0 c1"><span>brassmonkey.clientButtonStates[device.deviceId]</span></p><p class="c0 c1"><span>Toggle An Image Lets say you want to have a toggle type button. Below is how you would react to a touch event over an image called toggleOn. The coordinates of the image would have to be known. The same could be done with a BMButton. Replacing the &lsquo;up skin&rsquo; in both cases.</span></p><p class="c0 c1"><span>//get the child from the applicationScheme instance. var bmimage:BMImage = _controlScheme.getChildByName(&quot;toggleOn&quot;) as BMImage; var i:int=0; var d:AppDisplayObjectAssetReference; //get the replacement image var bmimage1:BMImage = _controlScheme.getChildByName(&quot;toggleOff&quot;) as BMImage;; d = bmimage1.assets[0]; // read the new image reference id i = parseInt(XML(d).attribute(&#39;resourceRef&#39;).toString()) ;</span></p><hr style="page-break-before:always;display:none;"><p class="c0"><img height="803" src="images/image09.png" width="621"><hr></p><p class="c0 c1"><span>//create a new &lsquo;up&rsquo; named object ref in the first position of the array. bmimage.assets[0]=new AppDisplayObjectAssetReference(&#39;up&#39;,i ); //send it along brassmonkey.session.updateControlScheme(device,_controlScheme.pageToString(1));</span></p><p class="c0 c1"><span class="c3">Control and Screen Resolutions</span></p><p class="c0 c1"><span>Devices will maintain aspect ratios of control designs. Screen coordinates are adjusted for touch events so that a single code path can be created where desired across all devices. Below are some snippets showing how to set up a square control scheme.</span></p><p class="c0 c1"><span>bm= new BMApplication(loaderInfo.parameters); bm.initiate(&quot;app name&quot;,1); bm.addEventListener(DeviceEvent.DEVICE_LOADED, onLoaded); bm.addEventListener(DeviceEvent.DEVICE_DISCONNECTED, onUnloaded); // A square scheme to be held in landscape mode.</span></p><p class="c0 c1"><span>var sq:SquareScheme=new SquareScheme(); //set the scaler to the screen size the controls were created for. StageScaler.LONG=768; StageScaler.SHORT=768; //parse the scheme, and add the actual design orientation, width and height. appScheme = BMControls.parseDynamicMovieClip(sq,false,true,&#39;landscape&#39;,768,768 );</span></p><p class="c0 c1"><span>// Add controls to the list of schemes. bm.session.registry.validateAndAddControlXML(appScheme.toString()); // GO! bm.start();</span></p></body></html>