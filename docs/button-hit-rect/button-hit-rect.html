<html><head><title>Simple Hit Rect</title><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=lhDjYqiy3mZ0x6ROQEUoUw');ol{margin:0;padding:0}.c11{max-width:468pt;background-color:#ffffff;padding:72pt 72pt 72pt 72pt}.c1{font-size:10pt;font-family:"Consolas"}.c4{color:#990000;font-weight:bold}.c2{direction:ltr;margin-left:36pt}.c9{color:#009900;font-style:italic}.c0{height:11pt;direction:ltr}.c8{color:#0033ff}.c10{height:11pt}.c6{font-weight:bold}.c3{direction:ltr}.c5{font-size:24pt}.c7{color:#6699cc}.title{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:36pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}.subtitle{padding-top:18pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:24pt;font-family:"Georgia";padding-bottom:4pt}li{color:#000000;font-size:11pt;font-family:"Arial"}p{color:#000000;font-size:11pt;margin:0;font-family:"Arial"}h1{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:18pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}h2{padding-top:18pt;line-height:1.15;text-align:left;color:#000000;font-size:14pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h3{padding-top:14pt;line-height:1.15;text-align:left;color:#666666;font-size:12pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h4{padding-top:12pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:11pt;font-family:"Arial";padding-bottom:2pt}h5{padding-top:11pt;line-height:1.15;text-align:left;color:#666666;font-size:10pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}h6{padding-top:10pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:10pt;font-family:"Arial";padding-bottom:2pt}</style></head><body class="c11"><h1 class="c3"><span class="c5">A simpler look into the hit-rect api</span></h1><p class="c3"><span>The Brass Monkey control pad designs will typically use the graphics area of a button to sense any touches for script events. There are times when you might want to create a larger area than the button itself. Lets imagine we have a fast action game with two buttons, and that game-play is so intense that looking at the controls is not an option. We will have two buttons but we will divide the control area in half, reacting to a much larger area than the button graphics areas.</span></p><p class="c0"><span></span></p><p class="c0"><span></span></p><p class="c3"><span>The </span><span class="c6">ButtonHitRect</span><span>&nbsp;sample code will demonstrate how to set this up. The accompanying fla file in its lib folder provides a few simple assets for this purpose.</span></p><p class="c0"><span></span></p><p class="c0"><span></span></p><p class="c3"><span>An empty movie clip is created and prepared for export. It will be our device-client&#39;s control pad. A simple background symbol is defined, and and named-instance placed onto the empty movie clip. We&#39;ll call it &#39;background&#39;.</span></p><p class="c0"><span></span></p><p class="c0"><span></span></p><p class="c3"><img height="402" src="images/image01.jpg" width="591"></p><p class="c3"><span>A button symbol and a corresponding &#39;Down&#39; state is created. The control parser determines what are up-states and down-states by the qualified class name and the instance names. Here we have a &#39;SimpleButton&#39; and &#39;SimpleButtonDown&#39; symbols and we have placed the &#39;SimpleButton&#39; instances on the control pad where we want them to be, and we have given them script-names for our code hooks, &#39;left&#39; and &#39;right&#39; as their instance-names. The down-state symbol is placed onto the control pad movie clip, and it is not named. Only a single instance of the down state needs to be on the movie clip frame to be available for export.</span></p><p class="c0"><span></span></p><p class="c0"><span></span></p><p class="c3"><span>The Black hexagons are the &#39;left&#39; and &#39;right&#39; button instances. And the red hexagon is an unnamed instance which is associated as the down-state by qualified class naming conventions.</span></p><p class="c3"><img height="349" src="images/image00.jpg" width="693"></p><p class="c0"><span></span></p><p class="c0"><span></span></p><p class="c3"><span>Since the hypothetical game this control is for requires giant hit-rectangles for the best user experience, we will define another symbol for export. To make it easier to see and adjust the hit-rectangles of the two buttons, another pair of display objects are put on the stage. We&#39;ll name the instances as &#39;leftRect&#39; and &#39;rightRect&#39;, and place them where we want them. The two semi-transparent rectangles will be used as references and become the expanded hexagon button reaction areas.</span></p><p class="c0"><span></span></p><p class="c3"><img height="289" src="images/image03.jpg" width="375"></p><p class="c0"><span></span></p><p class="c0"><span></span></p><p class="c2"><span class="c1 c9">// A simple scheme to be held in landscape mode.</span></p><p class="c2"><span class="c1 c6 c7">var</span><span class="c1">&nbsp;sq:HitRectDemoScheme=</span><span class="c1 c8 c6">new</span><span class="c1">&nbsp;HitRectDemoScheme();</span></p><p class="c2 c10"><span class="c1"></span></p><p class="c2"><span class="c1 c9">//parse the scheme, and add the actual design orientation, width and height.</span></p><p class="c2"><span class="c1">appScheme = BMControls.parseDynamicMovieClip(sq,</span><span class="c1 c8 c6">false</span><span class="c1">,</span><span class="c1 c8 c6">true</span><span class="c1">,</span><span class="c1 c4">&#39;landscape&#39;</span><span class="c1">,480,320, AppDisplayObject.NEAREST);</span></p><p class="c2"><span class="c1 c9">//we will remove the reference display object from the control pad design but then assign their rectangles to the hexagon buttons.</span></p><p class="c2"><span class="c1 c6 c7">var</span><span class="c1">&nbsp;bmImageL:BMImage = appScheme.removeChildByName(</span><span class="c1 c4">&quot;leftRect&quot;</span><span class="c1">) </span><span class="c1 c6 c8">as</span><span class="c1">&nbsp;BMImage;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c2"><span class="c1 c6 c7">var</span><span class="c1">&nbsp;bmImageR:BMImage = appScheme.removeChildByName(</span><span class="c1 c4">&quot;rightRect&quot;</span><span class="c1">) </span><span class="c1 c8 c6">as</span><span class="c1">&nbsp;BMImage;</span></p><p class="c2"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c2"><span class="c1 c9">//Grab the hexagon button references by name.</span></p><p class="c2"><span class="c1 c6 c7">var</span><span class="c1">&nbsp;buttonL:BMButton= appScheme.getChildByName(</span><span class="c1 c4">&quot;left&quot;</span><span class="c1">) </span><span class="c1 c8 c6">as</span><span class="c1">&nbsp;BMButton;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c2"><span class="c1 c6 c7">var</span><span class="c1">&nbsp;buttonR:BMButton = appScheme.getChildByName(</span><span class="c1 c4">&quot;right&quot;</span><span class="c1">) </span><span class="c1 c8 c6">as</span><span class="c1">&nbsp;BMButton</span></p><p class="c2"><span class="c1 c9">//apply the new larger hit rect to the buttons.</span></p><p class="c2"><span class="c1">buttonL.hitRect=bmImageL.rect;</span></p><p class="c2"><span class="c1">buttonR.hitRect=bmImageR.rect;</span></p><p class="c2"><span class="c1 c9">// Add controls to the brassmonkey session.</span></p><p class="c2"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bm.session.registry.validateAndAddControlXML(appScheme.toString());</span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c3"><span class="c1">To make the touches more apparent, lets add a handler to the device for touches on top of button-presses. This will help illustrate the location of the touch and how the extended hit rectangle of the button will activate the downstate and script events. We will also add the control design onto the stage so you can reference the locations of the hit-rectangle display objects that were removed before sending to the device-clients.</span></p><p class="c0"><span class="c1"></span></p><p class="c0"><span class="c1"></span></p><p class="c3"><img height="281" src="images/image02.jpg" width="431"></p></body></html>